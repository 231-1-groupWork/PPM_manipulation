#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

typedef struct {
    int r, g, b;
} Pixel;

typedef struct {
    int width, height, maxval;
    Pixel *data; 
} Image;
int read_token(FILE *f, char *buf, int bufsize) {
    int c;
    
    while ((c = fgetc(f)) != EOF) {
        if (isspace(c)) continue;
        if (c == '#') { 
            while ((c = fgetc(f)) != EOF && c != '\n');
            continue;
        }
        ungetc(c, f);
        break;
    }
    if (c == EOF) return 0;
    int i = 0;
    while ((c = fgetc(f)) != EOF && !isspace(c)) {
        if (c == '#') { 
            ungetc(c, f);
            break;
        }
        if (i < bufsize - 1) buf[i++] = (char)c;
    }
    buf[i] = '\0';
    return 1;
}

int clamp_int(int x, int lo, int hi) {
    if (x < lo) return lo;
    if (x > hi) return hi;
    return x;
}

char *make_outname(const char *in, const char *suffix) {
    const char *last_slash1 = strrchr(in, '/');
    const char *last_slash2 = strrchr(in, '\\');
    const char *last_slash = last_slash1 > last_slash2 ? last_slash1 : last_slash2;
    const char *dot = strrchr(in, '.');
   
    if (dot && (!last_slash || dot > last_slash)) {
        size_t base_len = (size_t)(dot - in);
        size_t out_len = base_len + strlen(suffix) + strlen(dot) + 1;
        char *out = malloc(out_len);
        if (!out) return NULL;
        strncpy(out, in, base_len);
        out[base_len] = '\0';
        strcat(out, suffix);
        strcat(out, dot);
        return out;
    } else {
        size_t out_len = strlen(in) + strlen(suffix) + 5;
        char *out = malloc(out_len);
        if (!out) return NULL;
        strcpy(out, in);
        strcat(out, suffix);
        strcat(out, ".ppm");
        return out;
    }
}

int read_ppm(const char *filename, Image *img) {
    FILE *f = fopen(filename, "r");
    if (!f) return 0;
    char token[256];
    if (!read_token(f, token, sizeof(token))) { fclose(f); return 0; }
    if (strcmp(token, "P3") != 0) { fclose(f); return 0; }

    if (!read_token(f, token, sizeof(token))) { fclose(f); return 0; }
    img->width = atoi(token);
    if (!read_token(f, token, sizeof(token))) { fclose(f); return 0; }
    img->height = atoi(token);
    if (!read_token(f, token, sizeof(token))) { fclose(f); return 0; }
    img->maxval = atoi(token);

    if (img->width <= 0 || img->height <= 0 || img->maxval <= 0) { fclose(f); return 0; }

    long npix = (long)img->width * img->height;
    img->data = malloc(npix * sizeof(Pixel));
    if (!img->data) { fclose(f); return 0; }

    for (long i = 0; i < npix; ++i) {
        if (!read_token(f, token, sizeof(token))) { free(img->data); fclose(f); return 0; }
        img->data[i].r = atoi(token);
        if (!read_token(f, token, sizeof(token))) { free(img->data); fclose(f); return 0; }
        img->data[i].g = atoi(token);
        if (!read_token(f, token, sizeof(token))) { free(img->data); fclose(f); return 0; }
        img->data[i].b = atoi(token);
    }
    fclose(f);
    return 1;
}

int write_ppm(const char *filename, const Image *img) {
    FILE *f = fopen(filename, "w");
    if (!f) return 0;
    fprintf(f, "P3\n# generated by ppmviewer\n%d %d\n%d\n", img->width, img->height, img->maxval);
    int w = img->width;
    int h = img->height;
    for (int y = 0; y < h; ++y) {
        for (int x = 0; x < w; ++x) {
            long idx = (long)y * w + x;
            fprintf(f, "%d %d %d ", img->data[idx].r, img->data[idx].g, img->data[idx].b);
        }
        fprintf(f, "\n");
    }
    fclose(f);
    return 1;
}

void op_dom(Image *img, char color, int val) {
    int w = img->width, h = img->height;
    int maxv = img->maxval;
    for (int i = 0; i < w * h; ++i) {
        int r = img->data[i].r, g = img->data[i].g, b = img->data[i].b;
        char dom = 0;
        if (r > g && r > b) dom = 'R';
        else if (g > r && g > b) dom = 'G';
        else if (b > r && b > g) dom = 'B';
        
        if (dom == color) {
            img->data[i].r = clamp_int(r + val, 0, maxv);
            img->data[i].g = clamp_int(g + val, 0, maxv);
            img->data[i].b = clamp_int(b + val, 0, maxv);
        }
    }
}

void op_gris(Image *img) {
    int w = img->width, h = img->height;
    for (int i = 0; i < w * h; ++i) {
        int avg = (img->data[i].r + img->data[i].g + img->data[i].b) / 3;
        img->data[i].r = img->data[i].g = img->data[i].b = avg;
    }
}

void op_neg(Image *img) {
    int w = img->width, h = img->height, maxv = img->maxval;
    for (int i = 0; i < w * h; ++i) {
        img->data[i].r = maxv - img->data[i].r;
        img->data[i].g = maxv - img->data[i].g;
        img->data[i].b = maxv - img->data[i].b;
    }
}

int op_cut(const Image *in, int l1, int l2, int c1, int c2, Image *out) {
    int w = in->width, h = in->height;
    if (!(l1 < l2 && l2 <= h && c1 < c2 && c2 <= w)) return 0;
    int out_h = l2 - l1 + 1;
    int out_w = c2 - c1 + 1;
    out->width = out_w; out->height = out_h; out->maxval = in->maxval;
    long np = (long)out_w * out_h;
    out->data = malloc(np * sizeof(Pixel));
    if (!out->data) return 0;
    for (int r = 0; r < out_h; ++r) {
        for (int c = 0; c < out_w; ++c) {
            int in_r = (l1 - 1) + r;
            int in_c = (c1 - 1) + c;
            out->data[(long)r * out_w + c] = in->data[(long)in_r * w + in_c];
        }
    }
    return 1;
}


int int_cmp(const void *a, const void *b) {
    int aa = *(const int*)a; int bb = *(const int*)b;
    if (aa < bb) return -1;
    if (aa > bb) return 1;
    return 0;
}

int median_value(int *arr, int n) {
    qsort(arr, n, sizeof(int), int_cmp);
    return arr[n / 2]; 
}

int op_fil(const Image *in, Image *out) {
    int w = in->width, h = in->height;
    out->width = w; out->height = h; out->maxval = in->maxval;
    long np = (long)w * h;
    out->data = malloc(np * sizeof(Pixel));
    if (!out->data) return 0;
    for (int y = 0; y < h; ++y) {
        for (int x = 0; x < w; ++x) {
            int rvals[9], gvals[9], bvals[9];
            int cnt = 0;
            for (int dy = -1; dy <= 1; ++dy) {
                for (int dx = -1; dx <= 1; ++dx) {
                    int ny = y + dy, nx = x + dx;
                    if (ny >= 0 && ny < h && nx >= 0 && nx < w) {
                        Pixel p = in->data[(long)ny * w + nx];
                        rvals[cnt] = p.r;
                        gvals[cnt] = p.g;
                        bvals[cnt] = p.b;
                        cnt++;
                    }
                }
            }
            Pixel outp;
            outp.r = median_value(rvals, cnt);
            outp.g = median_value(gvals, cnt);
            outp.b = median_value(bvals, cnt);
            out->data[(long)y * w + x] = outp;
        }
    }
    return 1;
}

#define LINEBUFSZ 1024

int main(void) {
    char line[LINEBUFSZ];
    printf("Application de traitement d'images PPM réalisée par 231-1-groupeWork.\n");
    while (1) {
        printf("ppmviewer > ");
        if (!fgets(line, sizeof(line), stdin)) break;
        char *p = strchr(line, '\n'); if (p) *p = '\0';
        char *args[10];
        int argc = 0;
        char *tok = strtok(line, " \t");
        while (tok && argc < 10) { args[argc++] = tok; tok = strtok(NULL, " \t"); }
        if (argc == 0) continue;
        if (strcmp(args[0], "quit") == 0) break;
        else if (strcmp(args[0], "size") == 0) {
            if (argc != 2) { printf("usage: size fichier.ppm\n"); continue; }
            Image img;
            if (!read_ppm(args[1], &img)) { printf("fichier non trouvé\n"); continue; }
            printf("%d x %d\n", img.width, img.height);
           
            free(img.data);
        }
        else if (strcmp(args[0], "dom") == 0) {
            if (argc != 4) { printf("usage: dom <R|G|B> <val> fichier.ppm\n"); continue; }
            char color = toupper(args[1][0]);
            int val = atoi(args[2]);
            Image img;
            if (!read_ppm(args[3], &img)) { printf("fichier non trouvé\n"); continue; }
            op_dom(&img, color, val);
            char *out = make_outname(args[3], "_dom");
            if (!out) { free(img.data); printf("erreur mémoire\n"); continue; }
            if (!write_ppm(out, &img)) { printf("erreur écriture\n"); }
            else printf("opération effectuée ; %s créé\n", out);
            free(out);
            free(img.data);
        }
        else if (strcmp(args[0], "gris") == 0) {
            if (argc != 2) { printf("usage: gris fichier.ppm\n"); continue; }
            Image img;
            if (!read_ppm(args[1], &img)) { printf("fichier non trouvé\n"); continue; }
            op_gris(&img);
            char *out = make_outname(args[1], "_gris");
            if (!out) { free(img.data); printf("erreur mémoire\n"); continue; }
            if (!write_ppm(out, &img)) { printf("erreur écriture\n"); }
            else printf("opération effectuée ; %s créé\n", out);
            free(out);
            free(img.data);
        }
        else if (strcmp(args[0], "neg") == 0) {
            if (argc != 3) { printf("usage: neg infile.ppm outfile.ppm\n"); continue; }
            Image img;
            if (!read_ppm(args[1], &img)) { printf("fichier non trouvé\n"); continue; }
            op_neg(&img);
            if (!write_ppm(args[2], &img)) { printf("erreur écriture\n"); }
            else printf("opération effectuée\n");
            free(img.data);
        }
        else if (strcmp(args[0], "cut") == 0) {
            if (argc != 7) { printf("usage: cut infile l1 l2 c1 c2 outfile\n"); continue; }
            Image img;
            if (!read_ppm(args[1], &img)) { printf("fichier non trouvé\n"); continue; }
            int l1 = atoi(args[2]), l2 = atoi(args[3]), c1 = atoi(args[4]), c2 = atoi(args[5]);
            Image out;
            if (!op_cut(&img, l1, l2, c1, c2, &out)) { printf("paramètres de découpe invalides\n"); free(img.data); continue; }
            if (!write_ppm(args[6], &out)) { printf("erreur écriture\n"); }
            else printf("opération effectuée\n");
            free(img.data);
            free(out.data);
        }
        else if (strcmp(args[0], "fil") == 0) {
            if (argc != 3) { printf("usage: fil infile outfile\n"); continue; }
            Image img;
            if (!read_ppm(args[1], &img)) { printf("fichier non trouvé\n"); continue; }
            Image out;
            if (!op_fil(&img, &out)) { printf("erreur mémoire\n"); free(img.data); continue; }
            if (!write_ppm(args[2], &out)) { printf("erreur écriture\n"); }
            else printf("opération effectuée\n");
            free(img.data);
            free(out.data);
        }
        else {
            printf("commande inconnue\n");
        }
    }
    printf("bye\n");
    return 0;
}
